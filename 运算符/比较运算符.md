# 一、概述
比较运算符用于比较两个值的大小，然后返回一个**布尔值**，表示是否满足指定的条件。
```js
2 > 1 // true
```
> 注意，比较运算符可以比较各种类型的值，不仅仅是数值。

JavaScript 一共提供了8个比较运算符。
- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!==` 严格不相等运算符

# 二、非相等运算符：字符串的比较
JavaScript 引擎内部**首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点**，以此类推。
```js
'cat' > 'Cat' // true'
'大' > '小' // false
'2' > '11' // true 
'1' > '11' // false
```
上面代码中，小写的`c`的 Unicode 码点（`99`）大于大写的`C`的 Unicode 码点（`67`），所以返回true；“大”的 Unicode 码点是`22823`，“小”是`23567`，因此返回false；

# 三、非相等运算符：非字符串的比较
如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。
### 1. 原始类型值
如果两个运算子都是原始类型的值，则是先转成数值再比较。
```js
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1
```
注意：任何值（包括`NaN`本身）与`NaN`比较，返回的都是`false`。
```js
1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```
### 2. 对象
如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法
```js
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'
```
两个对象之间的比较也是如此。
```js
[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'

[2] > [11] // true
// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
// 即 '2' > '11'

{ x: 2 } >= { x: 1 } // true
// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```

# 四、严格相等运算符

JavaScript 提供两种相等运算符：`==`和`===`。

它们的区别是：
- `==`只比较两个值是否相等，只要值相等就返回`true`
- `===`比较它们是否为“同一个值”，只有值相等，类型也相同才会返回`true`

**建议不要使用相等运算符`==`，最好只使用严格相等运算符`===`**。
```js
1 == "1" // true
1 === "1" // false
"1" === "1" // true
```
### 1. 不同类型的值
如果两个值的类型不同，直接返回`false`。
```js
1 === "1" // false
true === "true" // false
```
### 2. 同一类的原始类型值
同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回`false`。
```js
1 === 0x1 // true
```
注意：`NaN`与任何值都不相等（包括自身）。另外，正`0`等于负`0`。
```js
NaN === NaN  // false
+0 === -0 // true
```
### 3. 复合类型值
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
```js
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```
如果两个变量引用同一个对象，则它们相等。
```js
var v1 = {};
var v2 = v1;
v1 === v2 // true
```
注意：对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。
```js
var obj1 = {};
var obj2 = {};

obj1 > obj2 // false 
obj1 < obj2 // false
obj1 === obj2 // false
```
### 4. undefined 和 null
`undefined`和`null`与自身严格相等。
```js
undefined === undefined // true
null === null // true
```
由于变量声明后默认值是`undefined`，因此两个只声明未赋值的变量是相等的。
```js
var v1;
var v2;
v1 === v2 // true
```

# 五、严格不相等运算符
严格相等运算符有一个对应的“严格不相等运算符”（`!==`），它的算法就是先求严格相等运算符的结果，然后返回相反值。
```js
1 !== '1' // true
// 等同于
!(1 === '1')
```

# 六、相等运算符
相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。
```js
1 == 1.0
// 等同于
1 === 1.0
```
比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。

# 七、不相等运算符
相等运算符有一个对应的“不相等运算符”（`!=`），它的算法就是先求相等运算符的结果，然后返回相反值。
```js
1 != '1' // false

// 等同于
!(1 == '1')
```
